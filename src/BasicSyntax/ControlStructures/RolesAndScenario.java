package BasicSyntax.ControlStructures;

public class RolesAndScenario {

    // https://stepik.org/lesson/12762/step/10?unit=3110

    // Вам дан список ролей и сценарий пьесы в виде массива строчек.

    // Каждая строчка сценария пьесы дана в следующем виде:
    // Роль: текст

    // Текст может содержать любые символы.

    // Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать результат в виде
    // готового текста (см. пример). Каждая группа распечатывается в следующем виде:

    // Роль:
    // i) текст
    // j) текст2
    // ...
    // ==перевод строки==

    // i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы следует в соответствии с
    // порядком ролей. Переводы строк между группами обязательны, переводы строк в конце текста не учитываются.

    // Заметим, что вам предстоит обработка огромной пьесы в 50 000 строк для 10 ролей - соответственно, неправильная
    // сборка результирующей строчки может выйти за ограничение по времени.

    // Обратите внимание еще на несколько нюансов:
    // * имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
    // * название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
    // * роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
    // * в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
    // * будьте внимательны, не добавляйте лишних пробелов в конце строк.

    // Sample Input:
    // roles:
    // Городничий
    // Аммос Федорович
    // Артемий Филиппович
    // Лука Лукич
    // textLines:
    // Городничий: Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
    // Аммос Федорович: Как ревизор?
    // Артемий Филиппович: Как ревизор?
    // Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
    // Аммос Федорович: Вот те на!
    // Артемий Филиппович: Вот не было заботы, так подай!
    // Лука Лукич: Господи боже! еще и с секретным предписаньем!

    // Sample Output:
    // Городничий:
    // 1) Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
    // 4) Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.

    // Аммос Федорович:
    // 2) Как ревизор?
    // 5) Вот те на!

    // Артемий Филиппович:
    // 3) Как ревизор?
    // 6) Вот не было заботы, так подай!

    // Лука Лукич:
    // 7) Господи боже! еще и с секретным предписаньем!

    // Для успешного прохождения текста №№.
    // Входные данные (stdin):
//    public static String[] my_roles = { "Городничий", "Аммос Федорович", "Артемий Филиппович", "Лука Лукич" };
//    public static String[] my_textLines =   {
//            "Городничий: Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.",
//            "Аммос Федорович: Как ревизор?", "Артемий Филиппович: Как ревизор?",
//            "Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.",
//            "Аммос Федорович: Вот те на!", "Артемий Филиппович: Вот не было заботы, так подай!",
//            "Лука Лукич: Господи боже! еще и с секретным предписаньем!",
//            "Городничий: Господа, сообщаю вам пренеприятное известие, его поведал мне Артемий Филиппович: к нам едет ревизор."
//    };
    // Выходные данные (stdout):
    // Городничий:
    // 1) Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
    // 4) Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
    // 8) Господа, сообщаю вам пренеприятное известие, его поведал мне Артемий Филиппович: к нам едет ревизор.

    // Аммос Федорович:
    // 2) Как ревизор?
    // 5) Вот те на!

    // Артемий Филиппович:
    // 3) Как ревизор?
    // 6) Вот не было заботы, так подай!

    // Лука Лукич:
    // 7) Господи боже! еще и с секретным предписаньем!

    // В тесте №3 может падать потому что:
    // роли могут быть такими
    // роль1
    // роль1 замена
    // когда фильтруешь строку можешь не ту роль взять

    // Роли в строках могут быть такими:
    // "Аммос Федорович: /тут реплика", а могут быть такими: "Аммос Федорович замена: /тут реплика".
    // Короче когда ищете в первоначальных строках с репликами имя роли, добавляйте двоеточие.

    // @Anonymous_2099990 прав
    // проверяйте так
    // if(stroka.startsWith(roles[i]+":")) // вот тут если не будет ":" может похожая роль проскочить
    // {
    //     добавляем индекс + вырезаем роль
    // }
    // @Maksim_Budilovskiy
    // хм, пробелы вообще нигде не используй
    // 1)if используй startsWith(role+:) без всяких пробелов
    // 2) вырезай с помощью replaceFirst(role+:)/substring(length+1) без всяких пробелов
    // то должно все работать по идее

    // 1) Взять из списка ролей 1ю роль, сформировать строку вида
    // Роль + : + \n
    // resuilts.append(roles[i]+ ":" + "\n");
    // 2) Найти строку, начинающуюся (startsWith) с Роль:,
    // вырезать "Роль:", что осталось - пронумеровать и прилепить к результрующей строке
    // [i]+")" + textString + \n
    // 3) Искать следующее вхождение роли и повторить п.2
    // 4) Если такой роли больше нет, перейти к следующей и повторить п.2 и п.3
    // 5) Если больше ролей нет вообще - вернуть то, что получилось

    // Не используйте replace, используйте replacefirst, чтобы удалить только первой вхождение роли в строке

    // Суммируя ответы:
    // StringBuilder вместо String (уж точно не StringBuffer)
    // Также присмотреться к методу startsWith, с помощью которого легко отличить вхождение "имя+двоеточие"
    // в началее строки и не задеть все остальные вхождения
    // А ещё удобно отрезать куски в начале строки с помощью substring(номер начального символа)
    // что позволяет опять же не создавать лишних сущностей и сократить код
    // Ну и стоит обратить внимание, что если создаете массив StringBuilder, то в начале он null
    // и это может приводить к ошибкам (что легко обходится проверкой == null,\
    // и пропустить их скорее всего не получится, компилятор даст знать)
    // А в остальном достаточно одного прохода по тексту, (хоть и придется на
    // // каждой строке бегать по ролям, но break вам в помощь)


    // We loop through each tole and each line of text,
    // and we group together all the lines of text for each tole in a single string output

//    private String printTextPerRole(String[] roles, String[] textLines) {
    public static String printTextPerRole(String[] roles, String[] textLines) {
        // Create a StringBuilder to hold the final output
        StringBuilder result = new StringBuilder();

        // Loop through each role
        for (int roleIndex = 0; roleIndex < roles.length; roleIndex++) {
            // Get the name of the current role
            String name = roles[roleIndex];

            // Add the role name to the output with a colon and newline symbol
            result.append(name).append(":").append("\n");

            // Loop through each line of the text
            for (int lineIndex = 0; lineIndex < textLines.length; lineIndex++) {
                // If the line starts with role name followed by a colon
                if (textLines[lineIndex].startsWith(name + ":")) {
                    // Append the line number, a closing parenthesis,
                    // the line without the role name, and a newline symbol to the output
                    result.append(lineIndex + 1)
                            .append(") ")
                            .append(textLines[lineIndex]
                            .replaceFirst(name + ": ", ""))
                            .append("\n");

                } System.out.println("Testing lineIndex: " + lineIndex); // Потом расскажи
            }
            // Add an extra newline to separate this role from the text
            result.append("\n");
        }
        return result.toString();
    }










}
